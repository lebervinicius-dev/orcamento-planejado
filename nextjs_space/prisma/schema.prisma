generator client {
    provider = "prisma-client-js"
    binaryTargets = ["native", "linux-musl-arm64-openssl-3.0.x"]
    output = "/home/ubuntu/orcamento_planejado/nextjs_space/node_modules/.prisma/client"
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

// Tabelas do NextAuth.js para autenticação
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
  id            String     @id @default(cuid())
  name          String?
  email         String     @unique
  emailVerified DateTime?
  image         String?
  password      String?    // Para autenticação email/senha
  phone         String?    // Telefone do usuário
  role          String     @default("user") // "user" ou "admin"
  status        UserStatus @default(ACTIVE) // Status da assinatura
  isActive      Boolean    @default(true) // Controle de acesso (legado - usar status)
  hotmartId     String?    @unique // ID da transação Hotmart para rastreamento
  resetToken    String?    // Token para recuperação de senha
  resetTokenExpiry DateTime? // Expiração do token de recuperação
  firstLogin    Boolean    @default(true) // Flag para forçar troca de senha no primeiro login
  lgpdConsentAt DateTime?  // Data/hora do consentimento LGPD
  accounts      Account[]
  sessions      Session[]

  // Relacionamentos para gestão financeira
  transactions  Transaction[]
  categories    Category[]
  aiAnalyses    AiAnalysis[]
  investments   Investment[]
  goals         Goal[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  canceledAt DateTime? // Data do cancelamento
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// Tabelas do sistema financeiro

model Category {
  id     String @id @default(cuid())
  name   String
  type   CategoryType // INCOME, EXPENSE ou INVESTMENT
  color  String? // Cor hex para visualizações (#00bf63, #737373, etc)
  userId String

  user         User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  transactions Transaction[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, name, type]) // Usuário não pode ter categoria duplicada por tipo
}

model Transaction {
  id          String          @id @default(cuid())
  amount      Decimal         @db.Decimal(12, 2) // Valor em R$ (suporta até R$ 9.999.999.999,99)
  description String
  date        DateTime
  type        TransactionType
  categoryId  String
  userId      String

  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  category Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId, date]) // Index para consultas por usuário e data
  @@index([userId, type]) // Index para consultas por usuário e tipo
  @@index([userId, createdAt]) // Index para ordenação por data de criação
}

model AiAnalysis {
  id          String   @id @default(cuid())
  title       String   // Título da análise (ex: "Análise Semanal - Janeiro 2024")
  content     String   @db.Text // Análise gerada pela IA em markdown
  periodStart DateTime // Início do período analisado
  periodEnd   DateTime // Fim do período analisado
  insights    String   @db.Text // Insights estruturados em formato JSON
  userId      String

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId, createdAt]) // Index para histórico de análises
  @@index([userId, periodStart, periodEnd]) // Index para consultas por período
}

model Investment {
  id          String   @id @default(cuid())
  name        String
  amount      Decimal  @db.Decimal(12, 2)
  date        DateTime @default(now())
  category    String   // Categoria de investimento (Renda Fixa, Ações, etc)
  goalId      String?
  userId      String

  user User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  goal Goal? @relation(fields: [goalId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId, date])
}

model Goal {
  id            String   @id @default(cuid())
  name          String
  targetAmount  Decimal  @db.Decimal(12, 2)
  progress      Decimal  @db.Decimal(12, 2) @default(0)
  userId        String

  user        User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  investments Investment[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
}

enum TransactionType {
  INCOME  // Receita/Entrada
  EXPENSE // Despesa/Saída
}

enum CategoryType {
  INCOME     // Categoria de Receita/Entrada
  EXPENSE    // Categoria de Despesa/Saída
  INVESTMENT // Categoria de Investimento
}

enum UserStatus {
  ACTIVE    // Usuário ativo e com acesso liberado
  SUSPENDED // Usuário temporariamente suspenso (pode ser reativado)
  CANCELED  // Assinatura cancelada (reembolso ou cancelamento definitivo)
}
